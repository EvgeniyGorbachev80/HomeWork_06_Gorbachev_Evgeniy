# ООП Дизайн и Solid

### Задание 

Взять реализованный код в рамках семинара 4 и продемонстрировать применение 
принципов, усвоенных на семинаре. Нужно в проекте прокомментировать участки 
кода, которые рефакторим, какой принцип применяем и почему.

**Для проверки соответствия Java класса принципам SOLID можно использовать следующий алгоритм действий:**

1. **Принцип единственной ответственности (SRP):**
Проверка: Убедитесь, что класс выполняет только одну ответственность или задачу. Если класс имеет несколько обязанностей, разделите его на более мелкие классы, каждый из которых будет отвечать за свою часть функциональности.
2. **Принцип открытости/закрытости (OCP):**
Проверка: Удостоверьтесь, что класс можно расширить для добавления новой функциональности, но при этом он остается закрытым для модификации. Для этого используйте наследование, интерфейсы, стратегии и т.д., чтобы обеспечить расширяемость без изменения существующего кода.
3. **Принцип подстановки Барбары Лисков (LSP):**
Проверка: Убедитесь, что подклассы могут быть использованы вместо их родительских классов без изменения корректности программы. При наследовании проверьте, что подклассы не изменяют предусловия и постусловия базовых методов.
4. **Принцип разделения интерфейса (ISP):**
Проверка: Разделите интерфейсы на более мелкие, специфические интерфейсы, чтобы клиенты зависели только от тех методов, которые им действительно нужны. Если класс реализует интерфейс, убедитесь, что он использует все методы этого интерфейса.
5. **Принцип инверсии зависимостей (DIP):**
Проверка: Убедитесь, что класс зависит от абстракций, а не от конкретных реализаций. Это достигается путем внедрения зависимостей через конструкторы, методы или DI-контейнеры.


   
Проверим по алгоритму класс **User**:

1. *Принцип единственной ответственности (SRP):*
Класс User отвечает только за представление и хранение информации о пользователе. Его единственная обязанность - хранить данные о пользователе и предоставлять методы для доступа и установки этих данных. Таким образом, этот класс соответствует принципу SRP.

2. *Принцип открытости/закрытости (OCP):*
В данном участке кода не наблюдается прямого применения принципа OCP. Класс User не предусматривает специфических механизмов расширения или закрытия для модификации.

3. *Принцип подстановки Барбары Лисков (LSP):*
В данном участке кода также не проверяется принцип LSP, поскольку нет иерархии классов, в которой подклассы могли бы использоваться вместо их родительских классов без изменения корректности программы.

4. *Принцип разделения интерфейса (ISP):*
Класс User предоставляет только методы для доступа и установки данных пользователя, что соответствует его обязанности. Он не реализует интерфейсы, а значит, не применимо к принципу ISP.

5. *Принцип инверсии зависимостей (DIP):*
В данном участке кода класс User не зависит от абстракций или интерфейсов, а зависит напрямую от конкретной реализации. Поэтому этот класс не соответствует принципу DIP.

Таким образом, из всех принципов SOLID применим только *принцип единственной ответственности (SRP)* к классу **User** в представленном участке кода.


Проверим по алгоритму класс **UserComparator**.

1. *Принцип единственной ответственности (SRP)*:
Класс UserComparator имеет одну ответственность - сравнивать пользователей по их имени, фамилии и отчеству. Он не занимается хранением данных или другими задачами, связанными с пользователями. Поэтому этот класс соответствует принципу SRP.

2. *Принцип открытости/закрытости (OCP)*:
В данном случае класс UserComparator открыт для расширения, так как можно добавить новые способы сравнения пользователей, изменяя логику внутри метода compare(), но при этом он остается закрытым для модификации. Таким образом, этот класс соответствует принципу OCP.

3. *Принцип подстановки Барбары Лисков (LSP)*:
Принцип LSP не применим в данном случае, так как класс UserComparator не является подклассом или частью иерархии классов.

4. *Принцип разделения интерфейса (ISP)*:
Класс UserComparator реализует интерфейс Comparator, который определяет только один метод compare(). Нет необходимости в каком-либо дополнительном разделении интерфейсов, поэтому этот принцип не применим.

5. *Принцип инверсии зависимостей (DIP)*:
Класс UserComparator зависит от абстракции User через интерфейс Comparator. Он использует методы доступа к данным пользователя, а не конкретные реализации. Поэтому этот класс соответствует принципу DIP.

Таким образом, из всех принципов SOLID применимы *принцип единственной ответственности (SRP)*, *принцип открытости/закрытости (OCP)* и *принцип инверсии зависимостей (DIP)* к классу **UserComparator**.


Проверим по алгоритму класс **Student.**

1. *Принцип единственной ответственности (SRP)*:
Класс Student отвечает за представление информации о студенте и имеет одну ответственность - хранить данные о студенте и предоставлять методы для доступа и установки этих данных. Таким образом, этот класс соответствует принципу SRP.

2. *Принцип открытости/закрытости (OCP)*:
Класс Student не предусматривает специфических механизмов расширения или закрытия для модификации. Он использует наследование от класса User, что позволяет добавить новые функции или методы в будущем без изменения существующего кода. Поэтому этот класс соответствует принципу OCP.

3. *Принцип подстановки Барбары Лисков (LSP)*:
Принцип LSP применим к иерархии классов и их подтипам. В данном случае, класс Student является подклассом класса User и не изменяет поведение родительского класса. Поэтому принцип LSP соблюдается.

4. *Принцип разделения интерфейса (ISP)*:
Класс Student не реализует интерфейсы, поэтому принцип ISP не применим.

5. *Принцип инверсии зависимостей (DIP)*:
Класс Student не зависит от конкретных реализаций, а зависит от абстракции User через наследование. Поэтому этот класс соответствует принципу DIP.

Таким образом, из всех принципов SOLID применимы, *принцип единственной ответственности (SRP)*, *принцип открытости/закрытости (OCP)*, *принцип подстановки Барбары Лисков (LSP)* и *принцип инверсии зависимостей (DIP)* к классу **Student**.

Проверим по алгоритму класс **StudentView.**

1. *Принцип единственной ответственности (SRP)*:
Класс StudentView имеет одну ответственность - отправлять информацию о студентах на консоль. Он не занимается хранением данных о студентах или другими задачами, не связанными с их отображением. Таким образом, этот класс соответствует принципу SRP.

2. *Принцип открытости/закрытости (OCP)*:
В данном случае класс StudentView закрыт для модификации, так как его функциональность написана непосредственно в методе sendOnConsole(). Однако, он открыт для расширения, так как можно создать новые классы представления для студентов, которые будут отличаться от этого, без изменения существующего кода. Таким образом, этот класс соответствует принципу OCP.

3. *Принцип подстановки Барбары Лисков (LSP)*:
Принцип LSP не применим в данном случае, так как класс StudentView не является подклассом или частью иерархии классов.

4. *Принцип разделения интерфейса (ISP)*:
Класс StudentView реализует интерфейс UserView, который определяет только один метод sendOnConsole(). Нет необходимости в каком-либо дополнительном разделении интерфейсов, поэтому этот принцип не применим.

5. *Принцип инверсии зависимостей (DIP)*:
Класс StudentView зависит от абстракции Student через интерфейс UserView. Это позволяет легко заменить тип объектов, которые StudentView может отображать, без изменения самого класса. Поэтому этот класс соответствует принципу DIP.

Таким образом, из всех принципов SOLID применимы, *принцип единственной ответственности (SRP)*, *принцип открытости/закрытости (OCP)* и *принцип инверсии зависимостей (DIP)* к классу **StudentView**.


Проверим по алгоритму класс **StudentController**.

1. *Принцип единственной ответственности (SRP)*:
Класс StudentController имеет несколько методов, каждый из которых отвечает за конкретную операцию с управлением студентами. Например, методы removeStudentByFIO, getSortedStudentList, getSortStudentByFIO выполняют операции удаления и сортировки студентов соответственно. Каждый метод отвечает только за одну задачу, что соответствует принципу SRP.

2. *Принцип открытости/закрытости (OCP)*:
Класс StudentController открыт для расширения, так как новые методы могут быть добавлены для обработки других операций с управлением студентами, не требуя изменения существующего кода. Таким образом, принцип OCP соблюдается.

3. *Принцип подстановки Барбары Лисков (LSP)*:
Принцип LSP не применим в данном случае, так как класс StudentController не является подклассом или частью иерархии классов.

4. *Принцип разделения интерфейса (ISP)*:
Класс StudentController реализует интерфейс UserController, который определяет только один метод create(). Нет необходимости в разделении интерфейса, поэтому этот принцип не применим.

5. *Принцип инверсии зависимостей (DIP)*:
Класс StudentController зависит от абстракций через свои зависимости на сервисы StudentGroupService и StreamService. Это позволяет легко заменить конкретные реализации сервисов, если это необходимо, и поддерживает принцип DIP.

Таким образом, из всех принципов SOLID применимы, *принцип единственной ответственности (SRP)*, *принцип открытости/закрытости (OCP)* и *принцип инверсии зависимостей (DIP)* к классу **StudentController**.


Проверим по алгоритму класс **StudentGroup.**

1. *Принцип единственной ответственности (SRP)*:
Класс StudentGroup отвечает за управление списком студентов и предоставляет методы для создания и получения списка студентов. Он также реализует интерфейс Iterable, что позволяет итерироваться по списку студентов. Таким образом, этот класс соответствует принципу SRP, так как выполняет только одну задачу - управление списком студентов.

2. *Принцип открытости/закрытости (OCP)*:
Класс StudentGroup не имеет методов, которые могли бы быть расширены или изменены без изменения самого класса. Однако, он открыт для расширения через реализацию интерфейса Iterable, который позволяет итерироваться по списку студентов. Это соответствует принципу OCP.

3. *Принцип подстановки Барбары Лисков (LSP)*:
Принцип LSP не применим в данном случае, так как класс StudentGroup не является подклассом или частью иерархии наследования.

4. *Принцип разделения интерфейса (ISP)*:
Класс StudentGroup реализует интерфейс Iterable, который определяет только один метод iterator(). Нет необходимости в разделении интерфейса, поэтому этот принцип не применим.

5. *Принцип инверсии зависимостей (DIP)*:
Класс StudentGroup не зависит от конкретных реализаций, а зависит только от абстракции Student через список studentList. Это соответствует принципу DIP.

Таким образом, из всех принципов SOLID применимы, *принцип единственной ответственности (SRP)*, *принцип открытости/закрытости (OCP)* и *принцип инверсии зависимостей (DIP)* к классу StudentGroup.


Проверим по алгоритму класс **StudentGroupIterator.**


1. *Принцип единственной ответственности (SRP)*:
Класс StudentGroupIterator отвечает за итерацию по списку студентов и их удаление. Однако, это может быть рассмотрено как нарушение принципа SRP, так как класс выполняет две различные задачи: итерацию по коллекции и удаление элементов из неё.

2. *Принцип открытости/закрытости (OCP)*:
Класс StudentGroupIterator закрыт для изменений, так как он жестко привязан к типу Student и к коллекции студентов. Если в будущем потребуется изменить тип коллекции или добавить поддержку другого типа элементов, это потребует изменения самого класса StudentGroupIterator, что нарушает принцип OCP.

3. *Принцип подстановки Барбары Лисков (LSP)*:
Класс StudentGroupIterator не является подклассом другого класса и не расширяет функциональность базового класса. Поэтому принцип LSP не применим.

4. *Принцип разделения интерфейса (ISP)*:
Класс StudentGroupIterator реализует только интерфейс Iterator, который определяет методы для итерации по коллекции. Он не предоставляет дополнительной функциональности, поэтому принцип ISP не применим.

5. *Принцип инверсии зависимостей (DIP)*:
Класс StudentGroupIterator жестко зависит от конкретной реализации коллекции студентов через конструктор, что нарушает принцип DIP. Если в будущем потребуется использовать другой тип коллекции или внести изменения в структуру коллекции, это потребует изменения самого класса StudentGroupIterator.

Таким образом, из принципов SOLID, класс StudentGroupIterator нарушает *принцип единственной ответственности (SRP)*, *принцип открытости/закрытости (OCP)* и *принцип инверсии зависимостей (DIP)*.


Проверим по алгоритму класс **StudentGroupService.**

1. *Принцип единственной ответственности (SRP)*:
Класс StudentGroupService выполняет ряд операций связанных с управлением группой студентов: удаление студентов по ФИО, получение отсортированного списка студентов и создание нового студента. Каждый метод выполняет только одну функцию, поэтому этот класс соответствует принципу SRP.

2. *Принцип открытости/закрытости (OCP)*:
Класс StudentGroupService закрыт для изменений, так как его методы работают с конкретным типом данных Student и конкретной реализацией StudentGroup. Однако, класс может быть расширен путем добавления новых методов для работы с группой студентов, не изменяя существующего кода. Таким образом, принцип OCP соблюдается.

3. *Принцип подстановки Барбары Лисков (LSP)*:
Класс StudentGroupService не является подклассом или частью иерархии наследования, поэтому принцип LSP не применим.

4. *Принцип разделения интерфейса (ISP)*:
Класс StudentGroupService не реализует интерфейсы, поэтому в данном случае принцип ISP не применим.

5. *Принцип инверсии зависимостей (DIP)*:
Класс StudentGroupService зависит от абстракции StudentGroup через поле studentGroup. Это позволяет передавать различные реализации StudentGroup, что соответствует принципу DIP.

Таким образом, из всех принципов SOLID применимы, *принцип единственной ответственности (SRP)*, *принцип открытости/закрытости (OCP)* и *принцип инверсии зависимостей (DIP)* к классу **StudentGroupService**.